Imports System
Imports System.Collections.Generic
Imports System.IO
Imports System.Linq
Imports OpenTK
Imports OpenTK.Mathematics
''' <summary> tout ce qui ne sert pas dans le projet </summary>
Partial Class ObjModel
#Region "Variables"
    ' split vertex data without sharing vertices for smoothing normals
    Private splitVertices As New List(Of Vector3)()
    Private splitNormals As New List(Of Vector3)()
    Private splitTexCoords As New List(Of Vector2)()
    Private splitVertexMap As New MultiMapList(Of Vector3, Integer)() ' pour construire la list des indices
    Private ReadOnly sharedVertexLookup As New SortedDictionary(Of Integer, Integer)()
    Private ReadOnly defaultMaterial As ObjMaterial
#End Region
    Friend Function Save(filename As String, Optional textured As Boolean = True, Optional matrix As Matrix4 = Nothing) As Boolean
#Region "format OBJ"
        Dim FlagMatrix As Boolean = Not matrix = Matrix4.Zero
        ' validate file name
        If String.IsNullOrEmpty(filename) Then
            _errorMessage = "File name is not defined."
            Return False
        End If
        Dim rotMat() As Single = Matrix4ToMaticeRotation(matrix)

        ' build mtl file name
        Dim Chemin = Path.GetDirectoryName(filename) & "\"
        Dim Name = Chemin & Path.GetFileNameWithoutExtension(filename) & ".obj"
        Dim mtlFile As String = Chemin & Path.GetFileNameWithoutExtension(filename) & ".mtl"

        'get the current time
        Dim T As Date = Date.Now()
        ' open a file
        Try
            Using outfile As StreamWriter = New StreamWriter(filename)
                ' print comment
                outfile.WriteLine($"# Generated by ObjModel. -- { T:f}")
                outfile.WriteLine($"# Triangle Count: { TriangleCount}")
                outfile.WriteLine($"#   Vertex Count: { VertexCount }")
                outfile.WriteLine($"#    Group Count: {GroupCount }")
                outfile.WriteLine()
                ' print mtl file name
                outfile.WriteLine("mtllib " & mtlFile)
                outfile.WriteLine()

                ' tmp containers to store unique values
                Dim vertexMap As New Dictionary(Of Vector3, Integer)()
                Dim normalMap As New Dictionary(Of Vector3, Integer)()
                Dim texCoordMap As New Dictionary(Of Vector2, Integer)()
                Dim vertexIds(_Vertices.Count - 1) As Integer
                Dim normalIds(_Normals.Count - 1) As Integer
                Dim texCoordIds(_TexCoords.Count - 1) As Integer
                Dim index, indexStock As Integer
                ' print vertices
                Dim v3 As New Vector3()
                Dim v2 As New Vector2()
                Dim i As Integer
                Dim count As Integer = _Vertices.Count

                ' print vertices
                index = 1 ' 1-base index
                For i = 0 To count - 1 Step 3
                    v3 = New Vector3(_Vertices(i), _Vertices(i + 1), _Vertices(i + 2))
                    ' add unique vertex position with index to the tmp map
                    If Not vertexMap.TryGetValue(v3, indexStock) Then
                        indexStock = index
                        vertexMap.Add(v3, index)
                        ' transform if necessary
                        If FlagMatrix Then
                            v3 = Transform(rotMat, v3)
                        End If
                        ' print it to the file
                        outfile.WriteLine(Vector3ToStr(v3, "v"))
                        index += 1 ' for next
                    End If
                    vertexIds(i \ 3) = indexStock ' store unique index
                Next i
                outfile.WriteLine()

                ' print normals
                index = 1 ' 1-base in OBJ
                For i = 0 To count - 1 Step 3
                    v3 = New Vector3(_Normals(i), _Normals(i + 1), _Normals(i + 2))
                    ' add unique vertex position with index to the tmp map
                    If Not normalMap.TryGetValue(v3, indexStock) Then
                        indexStock = index
                        normalMap.Add(v3, index)
                        ' transform if necessary
                        If FlagMatrix Then
                            v3 = Transform(rotMat, v3)
                        End If
                        ' print it to the file
                        outfile.WriteLine(Vector3ToStr(v3, "vn"))
                        index += 1
                    End If
                    normalIds(i \ 3) = indexStock ' store unique index
                Next i
                outfile.WriteLine()

                ' print texcoords
                count = _TexCoords.Count
                If textured AndAlso count > 0 Then
                    index = 1
                    For i = 0 To count - 1 Step 2
                        v2 = New Vector2(_TexCoords(i), _TexCoords(i + 1))
                        ' add unique uv with index to the tmp map
                        If Not texCoordMap.TryGetValue(v2, indexStock) Then
                            indexStock = index
                            texCoordMap.Add(v2, index)
                            outfile.WriteLine(Vector2ToStr(v2))
                            index += 1
                        End If
                        texCoordIds(i \ 2) = indexStock ' store unique index
                    Next i
                End If
                outfile.WriteLine()

                ' print groups
                count = GroupCount
                For i = 0 To count - 1
                    outfile.WriteLine("g " & groups(i).name)
                    If groups(i).materialName.Length > 0 Then
                        outfile.WriteLine("usemtl " & groups(i).materialName)
                    End If

                    ' print faces
                    Dim indices() As Integer = GroupIndices(i)
                    For J As Integer = 0 To indices.Length - 1 Step 3
                        If textured AndAlso _TexCoords.Count > 0 Then
                            outfile.Write($"f {vertexIds(indices(J))}/{texCoordIds(indices(J))}/{normalIds(indices(J))}")
                            outfile.Write($" {vertexIds(indices(J + 1))}/{texCoordIds(indices(J + 1))}/{normalIds(indices(J + 1))}")
                            outfile.WriteLine($" {vertexIds(indices(J + 2))}/{texCoordIds(indices(J + 2))}/{normalIds(indices(J + 2))}")
                        Else
                            outfile.Write($"f {vertexIds(indices(J))}//{normalIds(indices(J))}")
                            outfile.Write($" {vertexIds(indices(J + 1))}//{normalIds(indices(J + 1))}")
                            outfile.WriteLine($" {vertexIds(indices(J + 2))}//{normalIds(indices(J + 2))}")
                        End If
                    Next
                    outfile.WriteLine()
                Next i

                ' clean memory
                vertexMap.Clear()
                normalMap.Clear()
                texCoordMap.Clear()
                ' close opened file
            End Using
        Catch ex As Exception
            Console.WriteLine(ex.Message)
            _errorMessage = "Failed to open a file to save: " & filename
            Return False
        End Try
#End Region
#Region "Format MTL"
        ' write mtl file
        Try
            Using outfile As StreamWriter = New StreamWriter(mtlFile)
                ' print comment
                outfile.WriteLine($"# Generated by ObjModel. -- {T:f}")
                outfile.WriteLine("# Material Count: " & materials.Count)
                outfile.WriteLine()

                ' print newmtl
                Dim count = materials.Count
                For i = 0 To count - 1
                    Dim material As ObjMaterial = materials(i)
                    outfile.WriteLine("newmtl " & material.name)
                    outfile.WriteLine($"Ka {material.ambient.R} {material.ambient.G} {material.ambient.B}")
                    outfile.WriteLine($"Kd {material.diffuse.R} {material.diffuse.G} {material.diffuse.B}")
                    outfile.WriteLine($"Ks {material.specular.R} {material.specular.G} {material.specular.B}")
                    outfile.WriteLine("Ns " & material.shininess)
                    If Not String.IsNullOrEmpty(material.textureName) Then
                        outfile.WriteLine("map_Kd " & material.textureName)
                    End If
                    outfile.WriteLine()
                Next i
            End Using
        Catch ex As Exception
            _errorMessage = "Failed to open a mtl file to save:    " & mtlFile
            Return False
        End Try

        Return True
#End Region
    End Function

    Friend Sub SmoothNormals(ByVal angle As Single)
        ' clean up the previous
        splitVertices = New List(Of Vector3)()
        splitNormals = New List(Of Vector3)()
        splitTexCoords = New List(Of Vector2)()
        splitVertexMap = New MultiMapList(Of Vector3, Integer)
        sharedVertexLookup.Clear()

        ' a vertex on the hard edge should have separate vertex attributes at the
        ' shared vertex in OpenGL because position and normal must be paired in
        ' order to be drawn, so, we force to split faces for the hard edge faces.
        SplitFaces()

        ' copy face normal to the vertex normals, flatten(harden) the surface normals
        Dim indexCount As Integer = Indices.Count
        For i As Integer = 0 To indexCount - 1 Step 3
            Dim faceNormal = FaceNormals(i \ 3)
            For j As Integer = 0 To 2
                splitNormals(i + j) = faceNormal
            Next j
        Next i

        ' soften vertex normals at shared vertices
        AverageNormals(angle)

        ' join shared vertices only if all vertex attributes are same far each
        ' vertex. It will reduce the number of vertex attributes.
        JoinFaces()

        ' return memory to system after smoothing
        splitVertices.Clear()
        splitNormals.Clear()
        splitTexCoords.Clear()
        splitVertexMap.Clear()
        sharedVertexLookup.Clear()
    End Sub

    Friend Sub RemoveDuplicates()
        ' clean up the previous
        splitVertices = New List(Of Vector3)()
        splitNormals = New List(Of Vector3)()
        splitTexCoords = New List(Of Vector2)()
        splitVertexMap.Clear()
        sharedVertexLookup.Clear()

        ' make each face independent (not shared)
        SplitFaces()

        ' find same vertex data then store the shared vertices to sharedVertexLookup
        FindDuplicates()

        ' weld same vertex together
        JoinFaces()

        ' return memory to system after merging
        splitVertices.Clear()
        splitNormals.Clear()
        splitTexCoords.Clear()
        splitVertexMap.Clear()
        sharedVertexLookup.Clear()
    End Sub

    Private Sub JoinFaces()
        Dim vec3 As Vector3, vec2 As Vector2
        Dim index As Integer
        Dim vertexCount As Integer = splitVertices.Count
        Dim texCoordNeeded As Boolean = False
        If splitVertices.Count = splitTexCoords.Count Then
            texCoordNeeded = True
        End If

        Dim newIndexLookup As New SortedDictionary(Of Integer, Integer)()

        ' clear previous lists
        _Vertices.Clear()
        _Normals.Clear()
        _TexCoords.Clear()
        Indices.Clear()

        ' loop through all vertices
        For i As Integer = 0 To vertexCount - 1
            ' if index is same, then not shared, add as new vertex
            If sharedVertexLookup(i) = i Then
                vec3 = splitVertices(i) ' add position
                _Vertices.Add(vec3.X)
                _Vertices.Add(vec3.Y)
                _Vertices.Add(vec3.Z)

                vec3 = splitNormals(i) ' add normal
                _Normals.Add(vec3.X)
                _Normals.Add(vec3.Y)
                _Normals.Add(vec3.Z)

                index = _Vertices.Count \ 3 - 1 ' add index
                Indices.Add(index)

                newIndexLookup(i) = index ' remember new index for other shared vertex

                If texCoordNeeded Then ' add tex coord
                    vec2 = splitTexCoords(i)
                    _TexCoords.Add(vec2.X)
                    _TexCoords.Add(vec2.Y)
                End If
                ' shared vertex, add only index to the index list
            Else
                Indices.Add(newIndexLookup(sharedVertexLookup(i)))
            End If
        Next i
    End Sub

    Private Sub AverageNormals(ByVal angle As Single)
        Dim cosAngle As Single = CSng(Math.Cos(DegToRad * angle))

        ' first, find unique vertex keys
        Dim vertexKeys As List(Of Vector3) = splitVertexMap.Keys

        ' init shared vertex index map with itself
        Dim vertexCount As Integer = splitVertices.Count
        sharedVertexLookup.Clear()
        For i As Integer = 0 To vertexCount - 1
            sharedVertexLookup(i) = i
        Next i

        ' do average
        Dim faceIndex1 As Integer
        Dim faceIndex2 As Integer
        Dim vertexIndex1 As Integer
        Dim vertexIndex2 As Integer

        ' loop through each vertex
        For Cpt As Integer = 0 To vertexKeys.Count - 1
            ' get all indices with same vertex position
            Dim indexRange1 As List(Of Integer) = splitVertexMap(vertexKeys(Cpt))
            'It only checks the first normal. Must compare all normals in the range
            ' get normal of the first element
            vertexIndex1 = indexRange1(0)
            faceIndex1 = vertexIndex1 \ 3
            Dim normal1 = FaceNormals(faceIndex1)
            Dim sharedNormal = normal1

            ' compare with other vertex normals
            Dim NbIndex As Integer = indexRange1.Count
            Dim mapIter As Integer = 1
            Do While mapIter < NbIndex
                vertexIndex2 = indexRange1(mapIter)
                faceIndex2 = vertexIndex2 \ 3
                Dim normal2 = FaceNormals(faceIndex2)

                ' check if 2 normals are less than smooth angle
                If Vector3.Dot(normal1, normal2) > cosAngle Then
                    ' remember the shared vertex index, so we can join the vertex together
                    sharedVertexLookup(vertexIndex2) = vertexIndex1

                    sharedNormal += normal2 ' sum normal
                End If
                mapIter += 1
            Loop
            sharedNormal.Normalize() ' make it unit length

            splitNormals(vertexIndex1) = sharedNormal ' update only the first one
        Next
    End Sub

    Private Sub SplitFaces()
        ' check if texCoords need to be processed
        Dim hasTexCoords As Boolean = False
        If _TexCoords.Count > 0 Then
            hasTexCoords = True
        End If

        Dim vertex As Vector3
        Dim vertexIndex As Integer

        ' reserve container size
        Dim indexCount As Integer = Indices.Count
        splitVertices = New List(Of Vector3)(indexCount)
        splitNormals = New List(Of Vector3)(indexCount)
        If hasTexCoords Then
            splitTexCoords = New List(Of Vector2)(indexCount)
        End If

        ' copy vertex attributes, but split them as not shared
        For i As Integer = 0 To indexCount - 1 Step 3
            ' get 3 vertices and normals of a face
            vertexIndex = Indices(i) * 3
            vertex = New Vector3(_Vertices(vertexIndex), _Vertices(vertexIndex + 1), _Vertices(vertexIndex + 2))
            splitVertices.Add(vertex)
            splitVertexMap.Add(vertex, i)

            Dim normal = New Vector3(_Normals(vertexIndex), _Normals(vertexIndex + 1), _Normals(vertexIndex + 2))
            splitNormals.Add(normal)

            vertexIndex = Indices(i + 1) * 3
            vertex = New Vector3(_Vertices(vertexIndex), _Vertices(vertexIndex + 1), _Vertices(vertexIndex + 2))
            splitVertices.Add(vertex)
            splitVertexMap.Add(vertex, i + 1)

            normal = New Vector3(_Normals(vertexIndex), _Normals(vertexIndex + 1), _Normals(vertexIndex + 2))
            splitNormals.Add(normal)

            vertexIndex = Indices(i + 2) * 3
            vertex = New Vector3(_Vertices(vertexIndex), _Vertices(vertexIndex + 1), _Vertices(vertexIndex + 2))
            splitVertices.Add(vertex)
            splitVertexMap.Add(vertex, i + 2)

            normal = New Vector3(_Normals(vertexIndex), _Normals(vertexIndex + 1), _Normals(vertexIndex + 2))
            splitNormals.Add(normal)

            ' copy tex coords only if the original has it
            If hasTexCoords Then
                vertexIndex = Indices(i) * 2
                Dim texCoord = New Vector2(_TexCoords(vertexIndex), _TexCoords(vertexIndex + 1))
                splitTexCoords.Add(texCoord)

                vertexIndex = Indices(i + 1) * 2
                texCoord = New Vector2(_TexCoords(vertexIndex), _TexCoords(vertexIndex + 1))
                splitTexCoords.Add(texCoord)

                vertexIndex = Indices(i + 2) * 2
                texCoord = New Vector2(_TexCoords(vertexIndex), _TexCoords(vertexIndex + 1))
                splitTexCoords.Add(texCoord)
            End If
        Next i
    End Sub

    Private Sub FindDuplicates()
        ' first, find unique vertex keys
        Dim vertexKeys = splitVertexMap.Keys

        ' init shared vertex index map with itself
        sharedVertexLookup.Clear()
        Dim vertexCount As Integer = splitVertices.Count
        For i As Integer = 0 To vertexCount - 1
            sharedVertexLookup(i) = i
        Next i

        ' determine there is texCoords
        Dim texCoordNeeded As Boolean = False
        If splitVertices.Count = splitTexCoords.Count Then
            texCoordNeeded = True
        End If

        Dim texCoord1 As New Vector2()
        Dim texCoord2 As New Vector2()
        Dim index1 As Integer
        Dim index2 As Integer

        ' loop through each vertex to compare other vertices
        For Each Vertex As Vector3 In vertexKeys
            ' get all vertex indices with same vertex position
            Dim indexRange As List(Of Integer) = splitVertexMap(Vertex)

            Dim rangeCount As Integer = indexRange.Count
            For i As Integer = 0 To rangeCount - 1
                ' get the normal and texcoord of the first element
                index1 = indexRange(i)
                Dim normal1 = splitNormals(index1)
                If texCoordNeeded Then
                    texCoord1 = splitTexCoords(index1)
                End If

                ' compare with other vertex normals and texCoords
                For j As Integer = i + 1 To rangeCount - 1
                    index2 = indexRange(j)
                    Dim normal2 = splitNormals(index2)
                    If texCoordNeeded Then
                        texCoord2 = splitTexCoords(index2)
                    End If

                    ' check if 2 normals are same and 2 texCoords are same
                    If normal1 = normal2 AndAlso texCoord1 = texCoord2 Then
                        ' remember this shared vertex index, so we can join the vertex together
                        ' If the index and value of lookup are different, then it is
                        ' already set as duplicate. So, we update only where index and
                        ' value are same.
                        If sharedVertexLookup(index2) = index2 Then
                            sharedVertexLookup(index2) = index1
                        End If
                    End If
                Next j
            Next i
        Next
    End Sub

#Region "Propriétés"
    'vertex attributs
    Friend ReadOnly Property VertexCount As Integer
        Get
            Return _Vertices.Count \ 3
        End Get
    End Property

    Friend ReadOnly Property NormalCount As Integer
        Get
            Return _Normals.Count \ 3
        End Get
    End Property

    Friend ReadOnly Property TexCoordCount As Integer
        Get
            Return _TexCoords.Count \ 2
        End Get
    End Property

    Friend ReadOnly Property IndicesCount As Integer
        Get
            Return Indices.Count
        End Get
    End Property

    Friend ReadOnly Property TriangleCount As Integer
        Get
            Return Indices.Count \ 3
        End Get
    End Property

    Friend ReadOnly Property BoundingBox As BoundingBox
        Get
            Return bound
        End Get
    End Property
    ' données sous forme de tableaux
    Friend ReadOnly Property Vertices As Single()
        Get
            Return _Vertices.ToArray
        End Get
    End Property
    Friend ReadOnly Property Normals As Single()
        Get
            Return _Normals.ToArray
        End Get
    End Property
    Friend ReadOnly Property TexCoords As Single()
        Get
            Return _TexCoords.ToArray
        End Get
    End Property
    'group attributs
    Friend ReadOnly Property MaterialCount As Integer
        Get
            Return materials.Count
        End Get
    End Property
    Friend ReadOnly Property GroupMaterialName(index As Integer) As String
        Get
            If index >= 0 AndAlso index < groups.Count Then
                Return groups(index).materialName
            Else
                Return ""
            End If
        End Get
    End Property
    Friend Property GroupMaterial(index As Integer) As ObjMaterial
        Get
            Dim materialName As String = groups(index).materialName
            If materialName = "" Then
                Return defaultMaterial
            End If

            Dim mtlId As Integer = FindMaterial(materialName)
            If mtlId >= 0 Then
                Return materials(mtlId)
            Else
                Return defaultMaterial
            End If
        End Get
        Set(value As ObjMaterial)
            Dim materialName As String = groups(index).materialName
            Dim mtlId As Integer = FindMaterial(materialName)
            If mtlId >= 0 Then
                materials(mtlId) = value
            End If
        End Set
    End Property
    Friend ReadOnly Property GroupName(index As Integer) As String
        Get
            If index >= 0 AndAlso index < groups.Count Then
                Return groups(index).name
            Else
                Return ""
            End If
        End Get
    End Property
    ''' <summary> index de départ dans le tableau des indices </summary>
    ''' <param name="index"> N° de dans la collection de Groupes </param>
    Friend ReadOnly Property GroupIndiceOffset(index As Integer) As Integer
        Get
            If index >= 0 AndAlso index < groups.Count Then
                Return groups(index).indexOffset
            Else
                Return 0
            End If
        End Get
    End Property
    ' for interleave vertex : V/N ou V/N/T
    Friend ReadOnly Property InterleavedVerticesCount As Integer
        Get
            Return _InterleavedVertices.Length
        End Get
    End Property
    'for  path & file names
    Friend ReadOnly Property ObjFileName As String
        Get
            Return _objFileName
        End Get
    End Property
    Friend ReadOnly Property MtlFileName As String
        Get
            Return _mtlFileName
        End Get
    End Property
    Friend ReadOnly Property ObjDirectory As String
        Get
            Return _objDirectory
        End Get
    End Property
#End Region
#Region "procédures internes"
    Friend Sub PrintSelf()
        Console.Write("===== ObjModel =====" & Lf)
        Console.Write("Triangle Count: " & TriangleCount & Lf)
        Console.Write("   Index Count: " & IndicesCount & Lf)
        Console.Write("  Bounding Box: " & bound.ToString() & Lf)
        Console.Write("   Group Count: " & GroupCount & Lf)
        Console.Write("Material Count: " & materials.Count() & Lf)
        Console.Write("  Vertex Count: " & VertexCount & Lf)
        Console.Write("  Normal Count: " & NormalCount & Lf)
        Console.Write("TexCoord Count: " & TexCoordCount & Lf)

        ' info about each group
        For i As Integer = 0 To groups.Count - 1
            Console.Write(Lf & "[Group " & i & "]" & Lf)
            Console.Write("    Group Name: " & groups(i).name & Lf)
            Console.Write(" Material Name: " & groups(i).materialName & Lf)
            Console.Write("   Index Count: " & groups(i).indexCount & Lf)
            Console.Write("  Index Offset: " & groups(i).indexOffset & Lf)
        Next i

        ' info about each mtl
        For i As Integer = 0 To materials.Count() - 1
            Console.Write(Lf & "[Material " & i & "]" & Lf)
            Console.Write("     Name: " & materials(i).name & Lf)
            Console.Write("  Texture: " & materials(i).textureName & Lf)
            Console.Write("  Ambient: " & "(" & materials(i).ambient.R & ", " & materials(i).ambient.G & ", " & materials(i).ambient.B &
                          ", " & materials(i).ambient.A & ")" & Lf)
            Console.Write("  Diffuse: " & "(" & materials(i).diffuse.R & ", " & materials(i).diffuse.G & ", " & materials(i).diffuse.B &
                          ", " & materials(i).diffuse.A & ")" & Lf)
            Console.Write(" Specular: " & "(" & materials(i).specular.R & ", " & materials(i).specular.G & ", " & materials(i).specular.B &
                          ", " & materials(i).specular.A & ")" & Lf)
            Console.Write("Shininess: " & materials(i).shininess & Lf)
        Next i

        Console.Write(Lf)
    End Sub

    Private Shared Function Transform(mat() As Single, vec As Vector3) As Vector3
        Dim result As New Vector3 With {.X = mat(0) * vec.X + mat(1) * vec.Y + mat(2) * vec.Z + mat(3),
                                        .Y = mat(4) * vec.X + mat(5) * vec.Y + mat(6) * vec.Z + mat(7),
                                        .Z = mat(8) * vec.X + mat(9) * vec.Y + mat(10) * vec.Z + mat(11)}
        Return result
    End Function

    Private Shared Function Vector3ToStr(V As Vector3, Prefix As String) As String
        Return $"{Prefix} {V.X:G8} {V.Y:G8} {V.Z:G8}"
    End Function

    Private Shared Function Vector2ToStr(V As Vector2) As String
        Return $"vt {V.X:G8} {(1 - V.Y):G8}"
    End Function

    Private Shared Function Matrix4ToMaticeRotation(matrix As Matrix4) As Single()
        Dim rotMat() As Single = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}
        '@@ use only rotation part for normal transform
        rotMat(0) = matrix.M11
        rotMat(1) = matrix.M12
        rotMat(2) = matrix.M13
        rotMat(4) = matrix.M21
        rotMat(5) = matrix.M22
        rotMat(6) = matrix.M23
        rotMat(8) = matrix.M31
        rotMat(9) = matrix.M32
        rotMat(10) = matrix.M33

        Return rotMat
    End Function
#End Region
End Class
